---
title: "Parallel Dithering: Is a speedup reachable ?"
author: Quentin Guilloteau
classoption: twocolumn
header-includes:
    - \usepackage{graphicx}
    - \usepackage{tikz}
    - \usetikzlibrary{decorations.pathreplacing,angles,quotes}
output:
    pdf_document:
        keep_tex: true
        number_sections: true
        fig_caption: yes
    html_document:
        keep_tex: true
        number_sections: true
---

```{r setup, include=FALSE}
library(ggplot2)
library(dplyr)
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

## Dithering

Dithering is the action to convert a grey scale image into an image composed only of black and white pixels.


\begin{figure}[h]
    \center
    \includegraphics[width=170px]{Images/charlie.png}
    \caption{Grey Scale Image}
\end{figure}

\begin{figure}[h]
    \center
    \includegraphics[width=170px]{Images/charlie_d.png}
    \caption{Dithered Image}
\end{figure}

## Floyd-Steinberg Dithering

There are many different possible ditherings.
They all use the same principles, only some numerical constants change.
In this paper, we will only focus on the __Floyd-Steinberg Dithering__.
It uses error diffusion.

The error diffusion matrix is the following:

$$
\displaystyle \left[ \begin{matrix}
    0 & 0 & 0 \\
    0 & 0 & \frac{7}{16} \\
    \frac{3}{16} & \frac{5}{16} & \frac{1}{16} \\
    \end{matrix}
    \right]
$$

\begin{figure}
\label{fig:propagation}
\center
\begin{tikzpicture}
    \draw (0,0) grid (3,2);
    \draw [->] (1.5,1.5) -- (2.25,1.5);
    \draw [->] (1.5,1.5) -- (2.25,0.75);
    \draw [->] (1.5,1.5) -- (1.5,0.75);
    \draw [->] (1.5,1.5) -- (0.75,0.75);
    \draw (2.5, 1.5) node {$\frac{7}{16}$};
    \draw (2.5, 0.5) node {$\frac{1}{16}$};
    \draw (1.5, 0.5) node {$\frac{5}{16}$};
    \draw (0.5, 0.5) node {$\frac{3}{16}$};
\end{tikzpicture}
\caption{Error Diffusion for the Floyd-Steinberg Dithering}
\end{figure}

Figure \ref{fig:local_deps} shows another way to look at it, by considering the dependencies for a single pixel.

\begin{figure}
\center
\begin{tikzpicture}
    \draw (0,0) grid (3,2);
    \draw [->] (1.5,1.25) -- (1.5,0.75);
    \draw [->] (2.25,1.25) -- (1.75,0.75);
    \draw [->] (0.75,1.25) -- (1.25,0.75);
    \draw [->] (0.75,0.5) -- (1.25,0.5);
    \draw (2.5, 1.5) node {$\frac{3}{16}$};
    \draw (0.5, 1.5) node {$\frac{1}{16}$};
    \draw (1.5, 1.5) node {$\frac{5}{16}$};
    \draw (0.5, 0.5) node {$\frac{7}{16}$};
\end{tikzpicture}
\caption{Local Dependencies of the Floyd-Steinberg Dithering}
\label{fig:local_deps}
\end{figure}

## Pseudo-Code

We can write the pseudo code of the Floyd-Steinberg Dithering:

```C
for (y = 0; y < rows; y++) {
  for (x = 0; x < cols; x++) {
    // Computation of the error
    int old_value = pixels[y * cols + x];
    int new_value = (current_value < 127) ?
                    0 : 255;
    int error = old_value - new_value;
    pixels[y * cols + x] = new_value;

    // Error Propagation
    pixels[(y + 0) * cols + (x + 1)]
        += error * 7 / 16;
    pixels[(y + 1) * cols + (x + 1)]
        += error * 1 / 16;
    pixels[(y + 1) * cols + (x + 0)]
        += error * 5 / 16;
    pixels[(y + 1) * cols + (x - 1)]
        += error * 3 / 16;

  }
}
```

As we can see, this algorithm is _highly sequential_.
We have to start from the top left of the image and work ourselves to the right until we reach the end of the line.
Then we start again from the next line.


# Parallel Dithering

The main idea of the paralle dithering, is that the progression looks more like a triangle than a rectangle:


\begin{figure}
    \center
    \begin{tikzpicture}
        \draw (0,0) grid (5,4);
        \draw (0.5, 3.5) node {1};
        \draw [gray] (1.5, 3.5) node {2};
        \draw [red] (0.5, 2.5) node {3};
        \draw [red] (2.5, 3.5) node {3};

        \draw [orange] (3.5, 3.5) node {4};
        \draw [orange] (1.5, 2.5) node {4};

        \draw [blue] (0.5, 1.5) node {5};
        \draw [blue] (2.5, 2.5) node {5};
        \draw [blue] (4.5, 3.5) node {5};
    \end{tikzpicture}

\caption{Potential Parallel Execution}
\label{fig:ppe}
\end{figure}

Figure \ref{fig:ppe}, shows that there are indeed some possible parallism in the dithering process.
The numbers correspond to the order of the execution.
When some pixels have the same number, it means that they can be processed in parallel.

We also see that each line needs to be 2 pixels ahead of the line below.


## Alternate processes

### Presentation

The first idea is to alternate processes and giving them one line at the time to work with.

\begin{figure}
    \center
    \begin{tikzpicture}
        \draw (0,0) grid (5,4);
        \draw [blue,thick] (0,3.02) rectangle (5, 3.98);
        \draw [red,thick] (0,2.02) rectangle (5, 2.98);
        \draw [blue,thick] (0,1.02) rectangle (5, 1.98);
        \draw [red,thick] (0,0.02) rectangle (5, 0.98);

        \draw [blue] (2.5, 1.5) node {Process 0};
        \draw [blue] (2.5, 3.5) node {Process 0};
        \draw [red] (2.5, 0.5) node {Process 1};
        \draw [red] (2.5, 2.5) node {Process 1};
    \end{tikzpicture}

\caption{Data Distribution per Process}
\label{fig:alternate_processes}
\end{figure}

Figure \ref{fig:alternate_processes} gives an example of the distribution of data between 2 processes.

Process 0 will start working on the first pixel of its line.
As we saw in figure \ref{fig:ppe}, a process must be done processing pixel $n$ of its line for the next process to be able to process the pixel $n - 2$ of its own line.

### Implemenation Details

#### Data Structure

TODO

#### Distributing the lines to the processes

As one process has non adjacent lines, we have to define our own ``MPI_Vector_Type`` to properly send the correct lines to each process.

As we want process $P_{i}$ to have $\frac{n}{p}$ lines with $p - 1$ lines between each line and stating with the $i$th line.

```{C}
// Definition of the custom type
MPI_Type_vector(h / world_size,
                w, world_size * w,
                MPI_INT16_T, &PixelLine);
MPI_Type_commit(&PixelLine);
```

Unfortunatly, it is not possible to simply use the ``MPI_Scatter`` function to send the pixels to the processes.
Indeed, it will start the next ``PixelLine`` at the end of the previous one, however, we want it to start at the same position that the previous one with an offset of ``w``.

So we decided to simply call the ``MPI_Send`` function manually to scatter the lines among the processes.

#### Processing a line

Apart for the first line of the first process, every process has to receive the error from the above process to be able to process the pixels of its current line.

```{C}
MPI_Recv(&error_from_top, 1, MPI_INT16_T,
    (my_rank + world_size - 1) % world_size,
    0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
```

Once the error from has been received, we need to update the value of the current pixel.

```{C}
local_pixels[i + w * line_index]
        += error_from_top;
```

At this point, we can compute the new value for this pixel and its error to propagate.

```{C}
int16_t current_value =
    local_pixels[i + w * line_index];
int16_t new_value = (current_value < 127) ?
                    0 : 255;
local_pixels[i + w * line_index] = new_value;
int16_t error = current_value - new_value;
```

#### Propagating the error to the process below

As figure \ref{fig:propagation} shows, once its value updated, one pixel has to send its error to (at most) 3 pixels to the line below.
However, in order for the first error of the line to be send to the process below, we need to wait for the second pixel to be done processing as we want to send the error only once.

We decided to use a circular buffer of size 3 to manage this issue.

This buffer will store the cumulated errors to send to the process below until they are ready to be send.
We need a size of 3 because a pixel propagate its error to (at most) 3 pixels on the line below.

\begin{figure}
    \center
    \begin{tikzpicture}
        % Drawing the lines and buffers
        \draw (0,0) grid (4,1);
        \draw (0,2) grid (3,3);
        \draw (0,4) grid (4,5);

        % Drawing the lines
        \draw [->, dashed] (0.5,4.5) -- (0.5,2.75);
        \draw [->, dashed] (0.5,4.5) -- (1.25,2.75);
        \draw [black] (0.5, 4.75) node {1};
        \draw (0.5, 4.75) circle (0.15);

        \draw [->, dashed] (1.5,4.5) -- (0.75,2.75);
        \draw [->, dashed] (1.5,4.5) -- (1.5,2.75);
        \draw [->, dashed] (1.5,4.5) -- (2.25,2.75);
        \draw [black] (1.5, 4.75) node {2};
        \draw (1.5, 4.75) circle (0.15);

        \draw [->] (0.5,2.5) -- node {send} (0.5,0.5);
        \draw [black] (-0.1, 1.47) node {3};
        \draw (-0.1, 1.47) circle (0.15);

        % Legend
        \draw (-1, 4.5) node {line $i$};
        \draw (-1, 2.5) node {Buffer};
        \draw (-1, 0.5) node {line $i + 1$};

       \draw[decoration={brace,mirror,raise=5pt},decorate](-1.7,5) -- node[left=6pt] {$P_{k}$} (-1.7,2);
       \draw[decoration={brace,mirror,raise=5pt},decorate](-1.7,1) -- node[left=6pt] {$P_{k + 1}$} (-1.7,0);


    \end{tikzpicture}

\caption{Use of the cicular buffer}
\label{fig:circular buffer}
\end{figure}

Figure \ref{fig:circular_buffer} resumes the mechanism used with the buffer.

\begin{enumerate}
    \item The first pixel of line $i$ is processed on $P_{k}$. We add the proportions of the error to the corresponding cells of the buffer.
    \item The second pixel of line $i$ is processed on $P_{k}$. We add the propotions of the error to the corresponding cells of the buffer.
    \item The first cell of the buffer is ready to be send to $P_{k+1}$ (no more depencies). It contains the cumulated error for the first pixel of line $i+1$.
    \item Once send, we set the value of the sent cell back to 0.
\end{enumerate}


### Performance Analysis
\label{sec:alternate}

Let $p$ be the number of processors.
Let us consider a square image of size $n$.
Let $L$ be the latency of the network and $B$ its bandwidth.
Let $w$ be the processing time of a pixel.

It takes $2 \times ( p - 1)$ steps before processor $P_{p - 1}$ can start processing the first pixel of its first line.

Each processor has $\frac{n^2}{p}$ pixels.

Therefore there are in total $2\times ( p - 1) + \frac{n^2}{p}$ steps.

We thus have:

\begin{equation}
T(n, p) = \left( 2\times ( p - 1) + \frac{n^2}{p} \right) \times \left( w + L + \frac{1}{B}\right)
\end{equation}

The sequential time is: $w\times n^2$.

We can thus compute the speedup:

$$
\displaystyle S(n, p) = \frac{w \times n^2}{\left( 2\times ( p - 1) + \frac{n^2}{p} \right) \left( w + L + \frac{1}{B}\right)}
$$

The limit speedup is thus:

\begin{equation}
\displaystyle \lim_{n \rightarrow \infty} S(n, p) = \frac{w \times p}{w + L + \frac{1}{B}}
\end{equation}

The efficiency of this algorithm is:

\begin{equation}
\label{eq:eff1}
\displaystyle Eff(n, p)  = \lim_{n \rightarrow \infty} \frac{S(n, p)}{p} = \frac{1}{1 + \frac{L}{w} + \frac{1}{B \times w}}
\end{equation}

The efficiency of this algorithm (equation \ref{eq:eff1}) is less than one.
It thus means that it is not very efficient.

## Reducing the Granularity

### Presentation

Sending the error every time a process process a pixel introduce too much loss due to the latency.
We will try to reduce the granularity of the algorithm by grouping pixels per block.
We will then also send the errors per block.

TODO IMAGE

TODO Compute the min block size to be ok

### Upper bound for $k$

Let $w$ be the width of the image and $p$ be the number of processes.

In order to not have any idle time by the processes, we would like the process $P_{p-1}$ to have at least finished processing its first 2 blocks when process $P_{0}$ is done processing its line.

Otherwise, process $P_{0}$ would have to wait for process $P_{p-1}$ to send the error of the first block.

Let $k_{hi}$ be the lower bound of $k$ such that there is no busy waiting by the processes.

There are $\displaystyle \frac{w}{k}$ blocks to process on one line.

Once the first line will be done by process $P_{0}$, process $P_{p-1}$ would have processed $\frac{w}{k} - 2\times (p - 1)$.

We want the last process to have processed at least 2 blocks (so it can send the error of the first block to process $P_{0}$).

Thus,

\begin{equation}
\frac{w}{k} - 2\times (p - 1) \geq 2 \implies k \leq \frac{w}{2 \times p} = k_{hi}
\end{equation}


We took an example with an image of width 8192 pixels on 16 processors.
We doubled the block size starting from 2 pixels up to the total width of the image.

We can compute the upper bound for $k$:

\begin{equation}
k_{hi} = \frac{w}{2p} = \frac{8192}{2 \times 16} = 256
\end{equation}

```{r, echo=FALSE, fig.cap="\\label{fig:opti_k}Speedup depending on the block size ($k$)"}
df <- read.csv("../experiments/data/output_upper_bound_k.csv", header = TRUE, sep = " ")

df$speedup <- df$seq_time / df$par_time

df <- df %>% group_by(k) %>% summarise(mean = mean(speedup), sd = sd(speedup))

df$disp <- df$sd * 100 / df$mean

df$confidence_inf <- df$mean - 2 * df$sd
df$confidence_sup <- df$mean + 2 * df$sd

labels <- df$k
labels[labels == 256] <- "k_hi"

ggplot(data = df, aes(x = k, y = mean)) +
    theme_bw() +
    geom_errorbar(aes(ymin = confidence_inf, ymax = confidence_sup), width = 0.2) +
    geom_point() +
    geom_vline(xintercept = 256, color = "blue") +
    scale_x_continuous(trans = 'log2', breaks = df$k, labels = labels) +
    xlab("block size") +
    ylab("Speedup") +
    ggtitle("Speedup depending on the block size")
```

In figure \ref{fig:opti_k} we show that the speedup is indeed maximal for $k = k_{hi}$.

For the remaining of the experiments of this paper, we will take $k = k_{hi}$.

We can also see a dip in performance for $k = 16$.
We suspect that it must be linked to MPI having different ways to send the data depending on the size to send compared to a threshold.

### Implementation Details

### Performance Analysis

We pretty much have the same logic than in section \ref{sec:alternate}, with blocks instead of pixels.

We note $k$ the size of a block.
So a block contains $k$ pixels.

\begin{equation}
T(n, p) = \left( 2\times ( p - 1) + \frac{n^2}{p \times k} \right) \left( w \times k + L + \frac{k}{B}\right)
\end{equation}

We compute next the speedup of this new version:

$$
\displaystyle S(n, p) = \frac{w \times n^2}{\left( 2\times ( p - 1) + \frac{n^2}{p\times k} \right) \times \left( w \times k + L + \frac{k}{B}\right)}
$$

The limit speedup is thus:

\begin{equation}
\displaystyle \lim_{n \rightarrow \infty} S(n, p) = \frac{w \times p \times k}{w \times k + L + \frac{k}{B}}
\end{equation}

The efficiency of this algorithm is:

\begin{equation}
\label{eq:eff2}
\displaystyle Eff(n, p)  = \lim_{n \rightarrow \infty} \frac{S(n, p)}{p} = \frac{1}{1 + \frac{L}{w \times k} + \frac{1}{B\times w}}
\end{equation}

We see that we improve the efficiency of the algorithm by limiting the use of the network and reducing the global cost of the latency.

## Limiting the Impact of the Bandwidth

### Presentation

In order to reduce the impact of the bandwith, we must send less messages through the network.
In the previous section, we increased the size of the messages by sending pixels per block.
In this section, we will create blocks of lines.
Each process will have several blocks of lines.
Each block of line will contain $r$ lines of pixels.
Only the top and bottom lines of the block will require communications.
The remaining pixels will be processed sequentially.


TODO IMAGE

### Upper bound for $r$

In order to process the $i^{th}$ block of pixel of the last line of the block of line, we need to process the $(i + 1)^{th}$ block of the previous line of the block.

We can then compute the number of block to process first to be able to process the $i^{th}$ block of the last line:

\begin{equation}
\displaystyle \sum_{j=0}^{r-1} i + j = r\times i + \frac{(r-1)r}{2}
\end{equation}

So, to send the first error to the process below, we need to process the first 2 blocks of the last line (i.e. $i = 2$).
Thus, we need to process the total of $\frac{r(r + 3)}{2}$ blocks of pixels.

We don't want to have processes being busy waiting between when they finish processing their previous block of lines and when they start their next block of lines.

The time to send the first error to the first process is: $p\times \frac{r(r + 3)}{2}w$

The time to process an entire block of lines is: $N \times r \times w$

We want the error to be send before the first process is done processing its block of lines:

\begin{equation}
p\frac{r(r + 3)}{2}w \leq N r w
\end{equation}

So the upper bound for $r$ to eliminate busy waiting is:

\begin{equation}
r \leq \frac{2N}{p} - 3 = r_{hi}
\end{equation}

```{r, echo=FALSE, fig.cap="\\label{fig:opti_r}Speedup depending on the block size ($r$)"}
df <- read.csv("../experiments/data/output_upper_bound_r_new.csv", header = TRUE, sep = " ")
df_k <- read.csv("../experiments/data/output_upper_bound_r.csv", header = TRUE, sep = " ")

df$speedup <- df$seq_time / df$par_time
df_k$speedup <- df_k$seq_time / df_k$par_time


rmax <- (df$w/df$k - (df$p + 0.5)) / (df$p - 0.5)
rmax_k <- (df_k$w/df_k$k - (df_k$p + 0.5)) / (df_k$p - 0.5)
df <- df %>% group_by(r) %>% summarise(mean = mean(speedup), sd = sd(speedup))
df_k <- df_k %>% group_by(r) %>% summarise(mean = mean(speedup), sd = sd(speedup))

df$disp <- df$sd * 100 / df$mean

df$confidence_inf <- df$mean - 2 * df$sd
df$confidence_sup <- df$mean + 2 * df$sd

df_k$confidence_inf <- df_k$mean - 2 * df_k$sd
df_k$confidence_sup <- df_k$mean + 2 * df_k$sd

ggplot() +
    theme_bw() +
    geom_point(data = df, aes(x = r, y = mean), color = "red") +
    geom_errorbar(data = df, aes(x = r, y = mean, ymin = confidence_inf, ymax = confidence_sup), width = 0.2) +
    geom_vline(xintercept = rmax, color = "blue") +
    geom_point(data = df_k, aes(x = r, y = mean), color = "green") +
    geom_errorbar(data = df_k, aes(x = r, y = mean, ymin = confidence_inf, ymax = confidence_sup), width = 0.2) +
    geom_vline(xintercept = rmax_k, color = "blue") +
    scale_x_continuous(trans = 'log2', breaks = df$r) +
    xlab("block size") +
    ylab("Speedup") +
    ggtitle("Speedup depending on the block size")
```

### Implementation Details

### Performance Anlysis

We pretty much have the same logic than in section \ref{sec:alternate}, with blocks instead of pixels.

\begin{equation}
T(n, p) = \left( 2\times ( p - 1) + \frac{n^2}{p \times k \times r} \right) \times \left( w \times k \times r + L + \frac{k}{B}\right)
\end{equation}

We compute next the speedup of this new version:

$$
\displaystyle S(n, p) = \frac{w \times n^2}{\left( 2\times ( p - 1) + \frac{n^2}{p\times k \times r} \right) \left( w \times k \times r + L + \frac{k}{B}\right)}
$$

The limit speedup is thus:

\begin{equation}
\displaystyle \lim_{n \rightarrow \infty} S(n, p) = \frac{w \times p \times k \times r}{w \times k \times r + L + \frac{k}{B}}
\end{equation}

The efficiency of this algorithm is:

\begin{equation}
\label{eq:eff3}
\displaystyle Eff(n, p)  = \lim_{n \rightarrow \infty} \frac{S(n, p)}{p} = \frac{1}{1 + \frac{L}{w \times k \times r} + \frac{1}{B\times w \times r}}
\end{equation}

Once again, we manage to improve the efficiency of the algorithm by limiting the number of messages send.
However, the efficiency if always less than 1.

# Performances

# Conclusion

